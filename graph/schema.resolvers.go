package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"errors"
	"fmt"
	"log"
	"math"

	logger "github.com/hossam1231/logger-go-pkg"
	"mosque.icu/go_server/db"
	"mosque.icu/go_server/graph/model"
	"mosque.icu/go_server/services"
)

// User is the resolver for the user field.
func (r *articleResolver) User(ctx context.Context, obj *model.Article) (*model.User, error) {
	user, err := services.GetUser(obj.UserID)
	if err != nil {
		logger.Error("Error executing query:", err)
	}
	return user, nil

	//	query EstablishmentsArticles {
	//	  articles(establishmentId: "d2a958a8-74b9-4d02-9f5d-715108b94202") {
	//	    id
	//	    title
	//      description
	//      user {
	//      id
	//     firstName
	//     lastName
	//     }
	//	  }
	//	}

	//   query SpecificArticle {
	//    article(id: "2") {
	//     name
	//     type
	//     user {
	//     id
	//     firstName
	//     lastName
	//     }
	//    }
	//  }
}

// Comments is the resolver for the comments field.
func (r *articleResolver) Comments(ctx context.Context, obj *model.Article) ([]*model.Comment, error) {
	comments, err := services.GetArticleComments(obj.ID)
	if err != nil {
		logger.Error("Error executing query:", err)
	}
	return comments, nil
}

// User is the resolver for the user field.
func (r *commentResolver) User(ctx context.Context, obj *model.Comment) (*model.User, error) {
	user, err := services.GetUser(obj.UserID)
	if err != nil {
		logger.Error("Error executing query:", err)
		return nil, err
	}
	return user, nil

	//	query EstablishmentsArticles {
	//	  articles(establishmentId: "d2a958a8-74b9-4d02-9f5d-715108b94202") {
	//	    id
	//	    title
	//      description
	//      user {
	//      id
	//     firstName
	//     lastName
	//     }
	//	  }
	//	}

	//   query SpecificArticle {
	//    article(id: "d2a958a8-74b9-4d02-9f5d-715108b94202") {
	//     name
	//     type
	//     user {
	//     id
	//     firstName
	//     lastName
	//     }
	//    }
	//  }
}

// ParentComment is the resolver for the parentComment field.
func (r *commentResolver) ParentComment(ctx context.Context, obj *model.Comment) (*model.Comment, error) {
	comment, err := services.GetArticleComment(obj.ParentCommentID)
	if err != nil {
		logger.Error("Error executing query:", err)
		return nil, err
	}
	return comment, nil
}

// Events is the resolver for the events field.
func (r *establishmentResolver) Events(ctx context.Context, obj *model.Establishment) ([]*model.Event, error) {
	events, err := services.GetEstablishmentEvents(obj.ID, obj.DbID)
	if err != nil {
		logger.Error("Error getting establishment events")
	}
	return events, nil

	//	query NearEstablishments {
	//	  establishments(latitude: 30.2500, longitude: -97.7500, rangeInKM: 1.00) {
	//	    id
	//	    publicId
	//	    name
	//	    userId
	//	    type
	//	    dbId
	//      events{
	//      id
	//     title
	//     }
	//	  }
	//	}

	//   query GetEstablishment {
	//    establishment(id: "d2a958a8-74b9-4d02-9f5d-715108b94202") {
	//     name
	//     type
	//     events{
	//     id
	//     title
	//     }
	//    }
	//  }
}

// Articles is the resolver for the articles field.
func (r *establishmentResolver) Articles(ctx context.Context, obj *model.Establishment) ([]*model.Article, error) {
	// panic(fmt.Errorf("not implemented: Events - events"))
	// return &model.Establishment{DbID: obj.DbID, Name: "DbID " + obj.DbID}, nil
	articles, err := services.GetEstablishmentArticles(obj.ID, obj.DbID)
	if err != nil {
		logger.Error("Err", err)
	}
	return articles, nil

	//	query NearEstablishments {
	//	  establishments(latitude: 30.2500, longitude: -97.7500, rangeInKM: 1.00) {
	//	    id
	//	    publicId
	//	    name
	//	    userId
	//	    type
	//	    dbId
	//      articles{
	//      id
	//     title
	//     }
	//	  }
	//	}

	//   query GetEstablishment {
	//    establishment(id: "d2a958a8-74b9-4d02-9f5d-715108b94202") {
	//     name
	//     type
	//     articles{
	//     id
	//     title
	//     }
	//    }
	//  }
}

// Establishment is the resolver for the establishment field.
func (r *queryResolver) Establishment(ctx context.Context, id string) (*model.Establishment, error) {
	establishment, err := services.GetEstablishment(&id)
	return establishment, err

	// 	Open http://localhost:8080 in a browser. Here are some queries to try, querying for getting a specific establishment

	//  query GetEstablishment {
	// 	   establishment(id: "0ba62ab7-1e83-4341-a5c8-0d42cfc6d7a7") {
	// 	     id
	// 	     publicId
	// 	     name
	// 	     userId
	// 	     type
	// 	     dbId
	// 	   }
	// 	 }
}

// Establishments is the resolver for the establishments field.
func (r *queryResolver) Establishments(ctx context.Context, latitude *float64, longitude *float64, rangeInKm *float64, typeArg *string, city *string) ([]*model.Establishment, error) {
	// Check if rangeInKm is zero to avoid division by zero
	if *rangeInKm == 0 {
		return nil, errors.New("rangeInKm must be greater than zero")
	} else {
		logger.Info("Parameters:", "latitude:", *latitude, "longitude:", *longitude, "rangeInKm:", *rangeInKm)
	}

	const earthRadius = 6371 // Earth radius in kilometers

	rangeInMeters := float64(*rangeInKm) * 1000
	latitudeDelta := (rangeInMeters / earthRadius) * (180 / math.Pi)

	// Calculate the bounding box coordinates
	latitudeLowerBound := *latitude - latitudeDelta
	logger.Info("calculated lat lower bound:", latitudeLowerBound)

	latitudeUpperBound := *latitude + latitudeDelta
	logger.Info("calculated lat upper bound:", latitudeUpperBound)

	longitudeDelta := (rangeInMeters / earthRadius) * (180 / math.Pi) / math.Cos(*latitude*math.Pi/180)
	logger.Info("calculated longitudeDelta:", longitudeDelta)

	longitudeLowerBound := *longitude - longitudeDelta
	logger.Info("calculated lon lower bound:", longitudeLowerBound)

	longitudeUpperBound := *longitude + longitudeDelta
	logger.Info("calculated lon upper bound:", longitudeUpperBound)

	query := `
	SELECT id, publicId, name, userId, type, dbId, thumbnail FROM Establishment
	WHERE
	 latitude BETWEEN ? AND ?
	AND longitude BETWEEN ? AND ?
	// AND
	// ST_DISTANCE_SPHERE(point(?, ?), point(longitude, latitude)) < ?
	`

	database, err := db.Connect() // Call the Connect function
	if err != nil {
		log.Fatal(err)
	}

	// Execute the query and get the result
	rows, err := database.Query(query, latitudeLowerBound, latitudeUpperBound, longitudeLowerBound, longitudeUpperBound, longitude, latitude, rangeInMeters)
	if err != nil {
		log.Fatal(err)
		logger.Error("Error executing query:", err)
		return nil, err
	} else {
		logger.Success("Success getting rows")
	}
	defer rows.Close()

	// Create a slice to store the retrieved establishments
	establishments := []*model.Establishment{}

	// Iterate through the rows and scan each into an Establishment struct
	for rows.Next() {
		establishment := &model.Establishment{}
		err := rows.Scan(&establishment.ID, &establishment.PublicID, &establishment.Name, &establishment.UserID, &establishment.Type, &establishment.DbID, &establishment.Thumbnail)
		if err != nil {
			logger.Error("Error scanning row:", err)
			return nil, err
		}
		establishments = append(establishments, establishment)
	}

	// Check for errors in iterating over rows
	if err := rows.Err(); err != nil {
		logger.Error("Error iterating over rows:", err)
		return nil, err
	}

	// Log success message
	if establishments != nil && len(establishments) > 0 {
		logger.Success("Success retrieving establishments")
	} else {
		logger.Warning("No establishments satisfying the conditions")
		return nil, errors.New("No establishments satisfying the conditions")
	}
	// Return the retrieved establishments

	return establishments, nil

	// Example for testing: Use coordinates for a location in Austin, Texas, USA
	// Latitude: 30.2500, Longitude: -97.7500
	// This is just an example, feel free to use coordinates relevant to your testing scenario.

	// 	Open http://localhost:8080 in a browser. Here are some queries to try, querying for getting a specific establishment

	//	query NearEstablishments {
	//	  establishments(latitude: 30.2500, longitude: -97.7500, rangeInKM: 1.00) {
	//	    id
	//	    publicId
	//	    name
	//	    userId
	//	    type
	//	    dbId
	//	  }
	//	}
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string, dbID *string) (*model.Article, error) {
	article, err := services.GetArticle(id, dbID)
	if err != nil {
		logger.Error("Err", err)
	}
	return article, nil
}

// Article returns ArticleResolver implementation.
func (r *Resolver) Article() ArticleResolver { return &articleResolver{r} }

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Establishment returns EstablishmentResolver implementation.
func (r *Resolver) Establishment() EstablishmentResolver { return &establishmentResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type articleResolver struct{ *Resolver }
type commentResolver struct{ *Resolver }
type establishmentResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *articleResolver) Establishment(ctx context.Context, obj *model.Article) (*model.Establishment, error) {
	establishment, err := services.GetEstablishment(obj.EstablishmentID)
	if err != nil {
		logger.Error("Error executing query:", err)
		return nil, err
	}
	return establishment, nil
}
func (r *queryResolver) ArticlesByEstablishment(ctx context.Context, establishmentID *string, typeArg *string) ([]*model.Article, error) {
	panic(fmt.Errorf("not implemented: ArticlesByEstablishment - articlesByEstablishment"))
}
func (r *queryResolver) EventsByEstablishment(ctx context.Context, establishmentID *string, typeArg *string) ([]*model.Event, error) {
	panic(fmt.Errorf("not implemented: EventsByEstablishment - eventsByEstablishment"))
}
